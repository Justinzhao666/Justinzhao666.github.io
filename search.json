                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            [{"title":"Java程序运行和对象创建过程简述","date":"2019-06-05T12:45:49.000Z","url":"/2019/06/05/Java程序运行和对象创建过程简述/","tags":["Java"],"categories":["编程语言"],"content":"Java中一个对象创建分为两个步骤： 加载类，创建对象。加载类是将所写的程序.java文件编译生成的.class文件加载到内存中，保证了对象创建的预置环境。类加载完毕后才可以创建该类的对象。第一步：加载类当开始运行一个类，虚拟机首先试图访问指定启动类的 .main() 方法，加载该类的 .class 文件。如果该类有父类，那么继续加载其父类，以此类推，直到加载出所有与main入口类相关的类（它的父类，父类的父类等）。接着，从其顶级父类开始，对其static域按照顺序进行初始化！直至初始化完所有类的static域。&gt;将static域放到静态存储区。至此类的加载工作完毕了，下面就进入main函数，执行main函数。一般main函数中来创建类的对象，如果发现要创建的类没有被加载，则继续加载该类）第二步：对象创建为对象获取内存，然后将内存全部置为0，此时对象中的所有属性都是被赋予0的默认值（内存为0时候的默认值：null-对象引用，0-int，false-boolean…）&gt; 在堆中生成对象所需空间，全部初始化为0，具体成员属性值为堆上对应内存子块–正是因为这种机制，所以java可以保证所有的类对象的属性都会被初始化，但是局部不会被初始化。这里需要注意的是：一个对象内部组合了另一个对象，那么在堆中其实存的也是一个引用，这个引用指向被组合对象的堆内存地址（另外再创建）。当引用在内存的二进制数据都为0的时候，他的表现形式是null；当他指向的数据内容内存区数据都是0的时候，他的值为0，””，False等初始标准值。所谓初始化就是修改内存区的二进制数据，因为对象在创建时候第一步就将内存清0，所以保证了所有属性都能至少被初始化为标准初值！但是局部变量不一样，你不初始化，只是申明，那么开辟的内存区在栈中值会是一个未知数据（一旦使用该引用的话，使用的可能是你没有初始化而瞎几把乱指的地址）所以Java会代码检验的时候发现你使用了未初始化的引用，直接给予不通过，直接杜绝了这种可能性的发生。综上，Java中使用任何变量或引用，必须初始化，初始化就是将内存中旧的二进制数据要么清0，要么赋予你要赋的值！从顶级父类开始，按照申明顺序将给顶级父类的非static的成员属性初始化（static的只初始化一次在类加载阶段）&gt; 用属性定义的值覆盖0值。调用顶级父类的构造函数，如果有成员属性初始化则覆盖前一个申明时初始化值。&gt; 构造函数再次初始化，覆盖前面申明时初始化。以此类推，将所有的父级（先初始化属性，在调用构造，一层一层的构造完毕） 构造完成最后，初始化当前类的非static属性，再调用当前类的构造函数，完成所有初始化工作。注意：1、类中static部分是发生在类加载时期的，并且只初始化一次。因为类只加载一次，加载完后创建对象过程中不会再去初始化static部分的东西，所以之后根本不会再走那块初始化代码，又怎么初始化第二次呢？2、static的优先级是高于main函数执行的，因为它是在类加载时期初始化。当static作用的东西都加载完了才执行main，当然main是第一个被使用的static方法，但是虚拟机只是找到这个方法的位置，并不会先去执行里面的内容。2、对于类的普通成员属性初始化三个步骤：先全初始化为0，再用申明时候初始化值进行初始化，再调用构造函数进行初始化。实例程序：(来源于Thinking in Java)  "},{"title":"linux中的source命令和直接执行脚本的区别","date":"2019-06-05T12:44:05.000Z","url":"/2019/06/05/linux中的source命令和直接执行脚本的区别/","tags":["Linux"],"categories":["Linux"],"content":"source 以及 . 直接在当前的进程中读取脚本的配置，不会开一个新的进程！ source会将脚本的内容直接影响到父进程的（因为它不开辟新线程，可以说是直接在当前进程中加入脚本的执行内容）。所以你source之后，里面配置的变量都会加入到当前环境中，你可以在该shell中调用脚本中的变量！而./xx.sh 以及 sh xx.sh 是在当前进程下新开一个子shell进程运行这个脚本，当脚本运行完毕了，sh中设置的变量和子进程一起被销毁了！（该子shell继承了父进程的shell的环境变量，子shell结束了变量将被销毁，如果使用了export可以将子shell的变量反馈到父级别的shell中）"},{"title":"ThreadLocal理解-结合连接池","date":"2019-06-05T12:40:38.000Z","url":"/2019/06/05/ThreadLocal理解-结合连接池/","tags":["Java"],"categories":["编程语言"],"content":"本想看看博客理解下ThreadLocal，看了几篇看的似懂非懂，还看出一堆疑问。从很多博客中也看出了ThreadLocal感觉没表面那么简单，但是表述貌似也不好。ThreadLocal和Thread关系先来图说话（说半天源码真不如来张图）上面图描述Thread和ThreadLocal之间的关系，从此就能得出很多基础结论了：线程内部持有一个Map存放着自己的局部变量，这些变量的key是ThreadLocal对象（可以理解为什么叫做线程局部变量了吧）；有一个变量想放入线程的局部变量的你就需要创建一个ThreadLocal对象；ThreadLocal本身没有什么存储结构，只是提供了方法，所以变量不是存在ThreadLocal中的，ThreadLocal负责搬运。源码：就两个重要方法：set方法get方法ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了线程保持对象的方法和避免参数传递的方便的对象访问方式 （网上一段话，我没看明白，但是我知道作者想表达的get到的那个点，并且很有道理的样子）连接：文章先理清下ThreadLocal的作用到底是什么？它并不是为了自带了线程安全，并发控制这些机制，它是通过牺牲空间（创建额外更多的对象来），它的目的仅仅就是为了让线程使用自己的变量。—让同一个线程上的所有代码块都是使用的该变量。就拿数据库连接来说，如果没有使用ThreadLocal，那么势必我们会定义的一个数据库Connection，然后所有的线程共享它！但是这样是线程不安全的（connection控制着事物，会导致事物混乱）！那么我们就需要同步，但是同步是很耗性能的。所以使用ThreadLocal，可以理解为为每一个线程都创建一个Connection对象（当然实际不会这样）。这个Conncetion对象只被该线程使用。–所以，不是说有一个共享变量我们为了让他线程安全就将该变量放入ThreadLocal中就安全了，这样其实还是不安全的因为引用传递，ThreadLocal做法是为每个线程创建一个对象。这本身就是一种空间换时间的机制，没有什么屌的优化机制在里面。那你或许又问 这有什么用？空间换时间– 我们不需要使用同步块了，线程的局部中存的每个对象都是不一样的，所以不会有线程安全问题。所以之前不理解的将一个变量引用传入到ThreadLocal中这种场景本身对于ThreadLocal来讲没有意义，也就是说ThreadLocal不是用来干这个的（看了好多博客写着的意思就是讲一个Connection放入到ThreadLocal中就线程安全了？开玩笑！）连接池的应用第一次接触这个就是因为连接池始终记得：ThreadLocal 将一些线程不安全的变量，将用同步的方式转为为每个线程创建一个对象来实现线程安全。文章也是自己理解的，可能有不对的地方，请指正。"},{"title":"<xmp><? extend E> 和 <? super E> 深入理解</xmp>","date":"2019-06-05T11:53:29.000Z","url":"/2019/06/05/Java-泛型通配符/","tags":["Java"],"categories":["编程语言"],"content":"在读Java编程思想的时候，对泛型通配符的上下限定这块有点难以理解。其实平常我也没有用到过这个统配符，只是看着有点困惑便去网上搜了下，答案又各有说法，并且大都不是我想要的。泛型的优点就不多说了，作为一个编程语言的优秀特性，很多语言都支持泛型。在Java编码中泛型可以结合通配符来实现更多的扩展。Java使用 “?” 在泛型参数中做通配符，作用在于：当前你不知道指定该容器是什么类型，你可以是?占位，表明将来在使用的时候你再指明类型去使用。主要疑惑点Java使用通配符时候可以通过extends和super用来对将来指向容器的参数类型做限制： 向下限定: ? extends E 向上限定：? super E我起初最疑惑的地方是编译器如何知道对应的通配类型可以存放那些数据的。对这两个最基础的理解(结论)：&lt; ? extends E &gt;&lt; ? super E &gt;add: 允许添加 E和E的子类 元素！get: 可以获取元素，但是类的信息丢失了，所以返回只能使用Object引用来接受！如果需要自己的类型需要强制类型转换！分析前需要知道 一定谨记： 编译器使用list的时候，只知道list的泛型参数范围(?,E]，至于他后面指向了什么编译器不知道，list自己是什么类型也不确定。 因为运行时候，不会再list上标记后面指向的ArrayList的类型，而是用一个capture#1来标记（原理我暂时还不知道）。 由上，你使用list的时候，编译器所能获取的信息只有一个，list的泛型参数范围：(?,E] 或者 [E,?) 所以如果允许get或者add，为了安全一定要进行类型判断，保证类型安全！这些判断的依据来源也只有该参数范围！     那么问题来了： 我只知道(?,E] 或者 [E,?)的范围，不知道后面ArrayList具体是什么？所以我做出的决策只能是规定：只允许 E的父类 或者 E的子类 的对象添加！ （因为list不确定自己的类型，只知道自己的范围，所以它对应的可add对象的范围一定是这个泛型参数范围内无论取哪种类型都能保证add是类型安全的）。但是最终我们是要add进入ArrayList的，所以这个范围一定要ArrayList无论指定任何类型，都是类型安全的！实例代码：  分析&lt; ? extends E &gt;List &lt; ? extends A &gt; 表示 这个list里面存的是A的子类，具体是啥不知道，只知道范围！那可以设定分两个范围： A子类，A父类。对于add：A子类情况：如果你允许add的元素是A的子类，那么因为泛型参数限定? extends A，所以ArrayList可以指定的类型也是A的子类，那么无法保证add的对象一定ArrayList指定类型的子类对象，比如： ArrayList指定C, list却add了A()对象–这就是非法的！（因为list并不知道指定了C，它可以确定的范围就是可以add所有A的子类。）所以A子类该范围不行！A父类情况：ArrayList指定类型肯定实在(?,A]范围内，所以这种情况肯定不行！对于get:list不知道你存入ArrayList是什么类型，但是我可以确定使用A的引用肯定可以接受ArrayList中的元素（无论ArrayList设定什么类型），因为A肯定是里面元素的父类！但是你使用其他类型接受就不行了，因为如果ArrayList的类型是你指定的那个类型的父类，是接受不了的。&lt; ? super E &gt;List &lt; ? super C &gt; 表示list里面存的是C和其父类，具体是啥不确定，只知道范围。同样的分为：C子类，C父类。（其实应该发现了没必要分为两类，有一类是肯定不行的）。add：C子类：如果允许add，就允许list来add任何C的子类元素，因为ArrayList指定的范围是C和其父类，所以ArrayList可以准确接受该假设范围的所有对象。 所以，C子类这个范围可行，这样就有一个标准的类型判断依据，不像extends，根本无法确定判断标准，编译器就不会知道怎么做。C父类：显然和上面A子类情况是一样的！因为list无法知道ArrayList指定类型 ，所以无法确定判断标准。get:因为list只允许add C的子子类对象，你或许也在想：那我直接用C不就可以接受ArrayList数据吗？并不是的，ArrayList在赋给list之前可能里面已经有值了，这个值的类型如果是ArrayList指定类型，并且是C的父类，那么C就无法接受！ 而且list不知道ArrayList会指定哪个类型，只知道范围，所以无法确定是哪个父类，所以干脆用Object那肯定就能接受了，所以返回的其实只有Object能接受，否则就得强转。文章很久前写的了，写的不好，现在我自己看也懵逼了 -。-|| 后期修正下吧!"},{"title":"Java中的finalize()方法","date":"2019-06-05T08:16:23.000Z","url":"/2019/06/05/Java-finalize/","tags":["Java"],"categories":["编程语言"],"content":"Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！finalize方法的作用：日常开发中我们不需要也不建议同时也没意义去主动调用finalize方法。由JVM管理的内存交给GC来管理即可。finalize的目的主要用于一些特殊内存：比如使用JNI调用中申请的特殊内存等。finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。再看垃圾回收Java的垃圾回收器只会释放由我们new出来的内存堆块，那些不是由new出来的“特殊内存”，垃圾回收器是不会管理的。所谓的特殊内存指通过JNI用C/C++向系统申请的内存，这些内存如果不手动去清除就会一直占据在内存中。而且，垃圾回收本身就有开销，所以虚拟机不会经常GC，只有当内存快要耗尽的时候JVM才会触发GC。finalize()由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。当系统进行GC的时候会先调用finalize方法，然后再下次才会回收对象的内存。因为native中申请的内存，GC没有办法回收所以finalize被用来做垃圾回前的重要清理工作：释放特殊内存。所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！如果GC不发生那么finalize也不会发生，finalize是Object的protect方法，不可以在类族外访问。对比析构函数首先，它不是析构函数。Java因为有GC机制，所以没有析构函数的概念！finalize不是C++中的析构函数：析构函数肯定是会销毁该对象的，但是finalize因为gc机制不会经常发生，所以其被执行的是不确定的。（不知道是不是我没理解透，没觉得这两个有什么可比性，一个主动发生一个被动发生）其他调用System.gc()，可以强制让gc发生来触发finalize方法！但是GC也只是GC垃圾的对象（没有被引用的），非垃圾的对象的finalize不会被调用。程序终止和GC不是一个概念。正常情况下你调用finalize(）都是直接super.finalize()使用父类的就行了。finalize一般不用！被执行的不确定性太大。不要指望使用finalize来回收你的对象，它只会在系统进行GC的时候清理特殊内存，不受你的控制！"},{"title":"2018总结-2019展望","date":"2019-06-05T06:11:03.000Z","url":"/2019/06/05/2019-规划/","tags":["个人总结"],"categories":["个人总结"],"content":"2018真的是一个刺激的一年！2018 回顾2019 展望需要学习的东西需要完成书籍其他"},{"title":"IDEA 的一些技巧","date":"2019-06-05T02:38:53.000Z","url":"/2019/06/05/IDEA-Skills/","tags":["IDE"],"categories":["IDE"],"content":"记录一下个人平时用IDEA时一些比较好用的插件、用法、功能特性、快捷键……使用代码块这是之前VisualStudio很喜欢的一个功能，没想到IDEA也有。代码块可以在代码全部缩进的时候方便的定位代码位置。使用方法：选中代码块 -&gt; cmd+opt+t -&gt; 用region注释包含代码块。一键生成所有set方法创建一个很多属性的对象，有时候不得不写set方法进行设置。这时候很容易乱了也很麻烦。使用方法：下载插件 -&gt;  -&gt; 构建对象时候.allset会自动有提示然后帮你一键生成set方法。"},{"title":"分布式数据库 - Paxos","date":"2019-03-06T06:57:18.000Z","url":"/2019/03/06/分布式数据库-Paxos/","tags":["分布式系统","一致性协议"],"categories":["一致性协议"],"content":"摘要内容文本内容"},{"title":"分布式数据库 - Raft","date":"2019-03-06T06:24:09.000Z","url":"/2019/03/06/分布式数据库-Raft/","tags":["分布式系统","一致性协议"],"categories":["一致性协议"],"content":"分布式数据库原理系列 之 Raft协议介绍过去, Paxos一直是分布式协议的标准，但是Paxos难于理解，更难以实现，Google的分布式锁系统Chubby作为Paxos实现曾经遭遇到很多坑。简介"},{"title":"设计模式 - 单例模式","date":"2019-03-06T06:13:35.000Z","url":"/2019/03/06/设计模式-单例模式/","tags":["设计模式"],"categories":["设计模式"],"content":"本文将介绍所有网络上流传的单例模式的各种写法，如有不足欢迎补充！文本内容"},{"title":"Hexo使用","date":"2019-03-04T07:28:31.000Z","url":"/2019/03/04/Hexo使用/","tags":["写作"],"categories":["写作工具"],"content":"新建一篇文章：hexo new “paper” "},{"title":"MarkDown使用","date":"2019-02-28T11:35:15.175Z","url":"/2019/02/28/MarkDown使用/","tags":["写作"],"categories":["写作工具"],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new postMore info: WritingRun serverMore info: ServerGenerate static filesMore info: GeneratingDeploy to remote sitesMore info: Deployment"}]